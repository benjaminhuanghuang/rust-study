线程是为了并行化计算密集型（CPU-bound）任务

线程就有两个重大问题：
* 使用大量（与其他解决方案相比）内存
*  启动和上下文切换的成本。

许多应用程序都是 I/O密集型(Input/Output-bound)应用程序.

线程是很久以前设计的，当时大多数计算都不是网络（Web）相关的东西，因此不适合太多并发 I/O 任务。

处理 I/O 任务的方式主要有两种：抢占式调度和协作式调度

抢占式调度(preemptive process scheduling)是指任务的调度不受开发人员控制，完全由运行时管理。无论程序员是启动同步任务还是异步任务，代码都没有区别。Go编程依靠的是抢占式调度。

其缺点是:
* 速度，受限于运行时Runtime的聪明程度。
* 难以调试bug。如果运行时有bug，可能极难发现，运行时is a  black-box。

在合作式调度下，开发者负责告诉运行时Runtime一个任务何时要花一些时间来等待I/O。这是给运行时（和编译器）的指示，任务将花费一些时间来等待操作完成，因此计算资源可以在此期间用于其他任务。

合作调度主要缺点:
- 更容易被滥用：如果一个等待被遗忘（幸运的是，Rust编译器会发出警告），或者事件循环被阻塞超过几微秒，就会对系统的性能产生灾难性的影响。


## Runtime
Rust标准库的async/await只是一个协程约定，本身不能干任何事，更没有规定底层实现是单还是多线程，规定这个的是你使用的运行时。而tokio就是这个运行时，其他的运行时还有像async_std等等，你自己也可以实现自己的运行时。

tokio线程池里各个线程从全局队列里取task来运行，如果有线程提前完成且无新任务，还会尝试从其他负载高的线程拿task过来做，也就是带work stealing的。



















